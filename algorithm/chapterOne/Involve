gcc **.c -o **//编译并生成名为（-o后面）**的可执行程序
./**运行程序
（8/5）
在我的环境下，float和int均为四字节，而浮点常量则是以8字节的double进行存储，而printf输出时,
float是当double处理的，同样是使用8字节，当一个四字节数据用八字节浮点数的形式读出的时候，也
就是会读之前的很多位0，最后按照（有效数字）×（基数2)pow(指数）的方式来取数，自然结果是0.0
(8/5单独输出)
在单独输出8/5时产生的是0.000000，而如果在输出8/5之前正常的输出一个浮点数据，那么在输出8/5
时则产生了一个接近于1.600000的结果，原因应该与上述理由相同，printf在使用%f输出整型常量时，
额外的读取了不属于整型大小的8字节数据，进而产生了区别于正确结果的输出。

原文链接：https://blog.csdn.net/qq_39395755/article/details/107389184